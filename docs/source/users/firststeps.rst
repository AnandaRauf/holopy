First steps
===========

Initially you'll probably find it helpful to work from a python shell
such as ipython.


Holopy can work with many types of data, but we use it most for
working with digital holographic images, so we will start with an
example of such.

.. _loading:

Loading and viewing a hologram
------------------------------

Let's say you have a digital hologram stored in the file
``image0001.tif``.  Holopy can import many different image formats,
including TIFF files, numpy data format files, and any image format
that can be handled by the Python Imaging Library.  But it's always
good to load your images in Holopy and view them to see if they are
imported correctly.  You can do this as follows ::

   import holopy as hp

   holo = hp.load('image0001.tif')

We use an alias import for holopy so that you can refer to it as hp
because you will be typing it a lot.  ``import holopy`` also works,
but then you need to type out holopy instead of just hp. The function
:func:`hp.load <holopy.core.io.io.load>` returns an :class:`.Image`, a
2D array of the pixel values.  You can view it::

   holopy.show(holo)

Subtracting a background image can frequently make your hologram look
much nicer.  If you can, take another image with the same optical setup
as the ``image0001.tif`` but without the object of interest in it.
Here we pretend you have called that image ``bg.tif`` but you can name
it whatever you want.  Then you can do::

  bg = hp.load('bg.tif')
  holo = holo - bg

I usually overwrite the original image with the background subtracted
image as illustrated above, but you can also give it a different name
to keep the raw image around.  Going forward we will just describe
loading holograms, but you should feel free to background subtract
them if you have backgrounds.  
   
.. note ::
   
  You can do math or image processing operations on ``holo`` just like
  you would for a normal `numpy
  <http://docs.scipy.org/doc/numpy/reference/arrays.html>`_ array.  For
  example::

    import scipy.ndimage
    import scipy.fftpack
    filtered_image = scipy.ndimage.uniform_filter(holo, [10,10])
    ffted_image = scipy.fftpack.fft2(holo)

.. _metadata:

Telling holopy about your optical train
---------------------------------------

The data object generated by simply loading a TIFF is not actually
valid for analysis because it does not contain any information about
the positions of the pixel measurements or the manner in which it was
recorded. This additional information is referred to as
:dfn:`metadata`, and you should provide such metadata whenever you want
to do real calculations on your data.

All of the objects Holopy uses for storing data also support the
addition of such metadata.  The most common metadata is pixel size and
optical information, described by an :class:`.Optics` object.  Because
of the prime importance of metadata, :func:`hp.load
<holopy.core.io.io.load>` supports associating it with data as it is
loaded ::

   optics = hp.core.Optics(wavelen=.660, index=1.33)

   holo = hp.load('image0001.tif', pixel_size = .1,  optics = optics)


In the first line of code above we create an instance of the Optics metadata class
containing the imaging laser wavelength and the medium refractive
index.  You can specify more metadata, but this is all we need for
now.  The second line loads the image data, tells it the pixel size of
the camera in the imaging plane for the image and that it was taken
with the previously defined optics object.

If you want to background subtract the image, you can use::

  holo = hp.load('image0001.tif', pixel_size = .1,  optics = optics) - hp.load('bg.tif')



.. note::

    The wavelength specified in the Optics object is the wavelength in
    vacuum. Holopy uses the given wavelength and medium refractive
    index to calculate the wavelength in the medium. The wavelength in
    the medium is available as::

        optics.med_wavelen
        0.49624060150375937


Using YAML files
----------------

Holopy can save and load all of its objects from `YAML
<http://www.yaml.org/>`_ files.  These are designed to be both human and
computer readable and provide both our serialization format, and an
alternative method for specifying things like optical metadata.

You can save an optics object for future use::

  holopy.save('optics.yaml', optics)

optics.yaml will look something like this (yours will not contain the
explanatory comments, you can add any comments you want by proceeding
them with a '#" character)

.. sourcecode:: yaml
  
  !Optics
  wavelen: 0.660    # Wavelength of light (in vacuum) used in creating holograms
  index: 1.33       # Index of medium
  polarization: [1.0, 0.0]
  divergence: 0.0

You can also write this file by hand.  In either case you can make an
:class:`.Optics` object from the file ::

         optics = holopy.load('optics.yaml')
         holo = holopy.load('image0001.tif', pixel_size = .1,  optics = optics)

:func:`hp.load <holopy.core.io.io.load>` will also accept the filename
of an metadata yaml file as the argument for the optics parameter and
automatically load the yaml file. ::

  holo = holopy.load('image0001.tif', pixel_size = .1, optics='optics.yaml')

.. Note::
   
   Data objects are a special case for yaml output because they
   will likely contain a large array of data.  They can still be saved, but will generate
   very large files that may not be easily opened in a text editor
   like other holopy yamls.

   For the curious advanced user, what we actually do is put a yaml
   header with optics and other information, and then encode the array
   of data as a .npy binary (as from np.save) all in the same file.  This
   keeps the whole object in a single file, but generates a file
   that is not quite as easy to work with as other yamls.  
